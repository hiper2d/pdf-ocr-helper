import { DocumentProcessorServiceClient } from '@google-cloud/documentai';
import { GoogleGenAI } from '@google/genai';
import { MODELS, API_CONFIG } from './constants';

export interface GoogleDocumentAIResult {
  text: string;
  entities: Array<{
    type: string;
    mentionText: string;
    confidence: number;
    pageNumber: number;
  }>;
  keyValuePairs: Array<{
    key: string;
    value: string;
    confidence: number;
    pageNumber: number;
  }>;
  tables: Array<{
    rows: string[][];
    confidence: number;
    pageNumber: number;
  }>;
  totalPages: number;
  processorType: string;
}

export class GoogleDocumentAIService {
  private documentAIClient: DocumentProcessorServiceClient;
  private genAI: GoogleGenAI;
  private projectId: string;
  private location: string;
  private processorId: string;

  constructor() {
    // Document AI setup
    this.projectId = process.env.GOOGLE_CLOUD_PROJECT_ID || '';
    this.location = API_CONFIG.GOOGLE.LOCATION;
    this.processorId = process.env.GOOGLE_DOCUMENT_AI_PROCESSOR_ID || '';

    if (!this.projectId || !this.processorId) {
      throw new Error('GOOGLE_CLOUD_PROJECT_ID and GOOGLE_DOCUMENT_AI_PROCESSOR_ID environment variables are required');
    }

    this.documentAIClient = new DocumentProcessorServiceClient();

    // Gemini AI setup for QA
    const geminiApiKey = process.env.GOOGLE_GEMINI_API_KEY;
    if (!geminiApiKey) {
      throw new Error('GOOGLE_GEMINI_API_KEY environment variable is required for Google AI QA');
    }
    
    this.genAI = new GoogleGenAI({ apiKey: geminiApiKey });
  }

  async processDocument(documentBuffer: Buffer, filename: string): Promise<GoogleDocumentAIResult> {
    try {
      console.log(`Processing document with Google Document AI: ${filename}, Size: ${Math.round(documentBuffer.length / 1024)}KB`);

      // Validate file size
      if (documentBuffer.length > API_CONFIG.GOOGLE.MAX_FILE_SIZE) {
        throw new Error(`File size (${Math.round(documentBuffer.length / 1024 / 1024)}MB) exceeds the 20MB limit for Google Document AI`);
      }

      // Determine MIME type based on file extension
      const mimeType = this.getMimeType(filename);
      
      // Configure the request
      const request = {
        name: `projects/${this.projectId}/locations/${this.location}/processors/${this.processorId}`,
        rawDocument: {
          content: documentBuffer,
          mimeType: mimeType,
        },
        fieldMask: {
          paths: [
            'text',
            'pages',
            'entities',
            'pages.form_fields', 
            'pages.tables'
          ]
        }
      };

      // Process the document
      const [result] = await this.documentAIClient.processDocument(request);
      const document = result.document;

      if (!document) {
        throw new Error('No document returned from Google Document AI');
      }

      return this.processDocumentAIResult(document, filename);

    } catch (error) {
      console.error('Error processing document with Google Document AI:', error);
      throw new Error(`Failed to process document with Google Document AI: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async answerQuestionWithGemini(extractedText: string, structuredData: any, question: string): Promise<string> {
    try {
      console.log(`Processing Q&A with Google Gemini: Question length: ${question.length} characters`);

      const prompt = this.buildGeminiPrompt(question, extractedText, structuredData);

      const response = await this.genAI.models.generateContent({
        model: MODELS.GOOGLE.GEMINI_PRO,
        contents: prompt,
      });

      const answer = response.text;

      if (!answer) {
        throw new Error('No answer generated by Google Gemini');
      }

      console.log(`Google Gemini Q&A completed, answer length: ${answer.length} characters`);
      return answer;

    } catch (error) {
      console.error('Error with Google Gemini Q&A:', error);
      throw new Error(`Failed to process Q&A with Google Gemini: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private getMimeType(filename: string): string {
    const extension = filename.toLowerCase().split('.').pop();
    
    switch (extension) {
      case 'pdf':
        return 'application/pdf';
      case 'png':
        return 'image/png';
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'gif':
        return 'image/gif';
      case 'webp':
        return 'image/webp';
      case 'tiff':
      case 'tif':
        return 'image/tiff';
      default:
        return 'application/pdf'; // Default to PDF
    }
  }

  private processDocumentAIResult(document: any, filename: string): GoogleDocumentAIResult {
    const text: string[] = [];
    const entities: Array<{type: string, mentionText: string, confidence: number, pageNumber: number}> = [];
    const keyValuePairs: Array<{key: string, value: string, confidence: number, pageNumber: number}> = [];
    const tables: Array<{rows: string[][], confidence: number, pageNumber: number}> = [];

    // Extract main text
    if (document.text) {
      text.push(document.text);
    }

    // Extract entities
    if (document.entities) {
      document.entities.forEach((entity: any, index: number) => {
        entities.push({
          type: entity.type || 'unknown',
          mentionText: entity.mentionText || '',
          confidence: entity.confidence || 0,
          pageNumber: this.getEntityPageNumber(entity, document) || 1
        });
      });
    }

    // Process pages for form fields and tables
    if (document.pages) {
      document.pages.forEach((page: any, pageIndex: number) => {
        const pageNumber = pageIndex + 1;

        // Extract form fields (key-value pairs)
        if (page.formFields) {
          page.formFields.forEach((field: any) => {
            const key = this.extractFieldText(field.fieldName, document.text);
            const value = this.extractFieldText(field.fieldValue, document.text);
            
            if (key || value) {
              keyValuePairs.push({
                key: key || 'Unknown',
                value: value || '',
                confidence: field.fieldName?.confidence || field.fieldValue?.confidence || 0,
                pageNumber
              });
            }
          });
        }

        // Extract tables
        if (page.tables) {
          page.tables.forEach((table: any) => {
            const tableData = this.extractTableFromGoogleAI(table, document.text);
            if (tableData.rows.length > 0) {
              tables.push({
                rows: tableData.rows,
                confidence: table.confidence || 0,
                pageNumber
              });
            }
          });
        }
      });
    }

    const totalPages = document.pages ? document.pages.length : 1;

    return {
      text: text.join('\n'),
      entities,
      keyValuePairs,
      tables,
      totalPages,
      processorType: 'Google Document AI'
    };
  }

  private extractFieldText(field: any, documentText: string): string {
    if (!field || !field.textAnchor) {
      return '';
    }

    if (field.textAnchor.textSegments && field.textAnchor.textSegments.length > 0) {
      const segment = field.textAnchor.textSegments[0];
      const startIndex = parseInt(segment.startIndex) || 0;
      const endIndex = parseInt(segment.endIndex) || startIndex;
      
      return documentText.substring(startIndex, endIndex).trim();
    }

    return '';
  }

  private extractTableFromGoogleAI(table: any, documentText: string): { rows: string[][] } {
    const rows: string[][] = [];

    if (!table.bodyRows) {
      return { rows };
    }

    // Process header row if exists
    if (table.headerRows && table.headerRows.length > 0) {
      table.headerRows.forEach((headerRow: any) => {
        const row = this.extractRowCells(headerRow, documentText);
        if (row.length > 0) {
          rows.push(row);
        }
      });
    }

    // Process body rows
    table.bodyRows.forEach((bodyRow: any) => {
      const row = this.extractRowCells(bodyRow, documentText);
      if (row.length > 0) {
        rows.push(row);
      }
    });

    return { rows };
  }

  private extractRowCells(row: any, documentText: string): string[] {
    const cells: string[] = [];

    if (row.cells) {
      row.cells.forEach((cell: any) => {
        const cellText = this.extractFieldText(cell.layout, documentText);
        cells.push(cellText);
      });
    }

    return cells;
  }

  private getEntityPageNumber(entity: any, document: any): number {
    if (!entity.pageAnchor || !entity.pageAnchor.pageRefs || entity.pageAnchor.pageRefs.length === 0) {
      return 1;
    }

    const pageRef = entity.pageAnchor.pageRefs[0];
    return (pageRef.page || 0) + 1; // Convert from 0-based to 1-based
  }

  private buildGeminiPrompt(question: string, extractedText: string, structuredData?: any): string {
    let prompt = `Based on the following extracted data from a document, please answer the question.

Document Text:
${extractedText}`;

    // Add structured data if available
    if (structuredData) {
      if (structuredData.entities && structuredData.entities.length > 0) {
        prompt += `\n\nEntities:`;
        structuredData.entities.forEach((entity: any) => {
          prompt += `\n- ${entity.type}: ${entity.mentionText} (Page ${entity.pageNumber})`;
        });
      }

      if (structuredData.keyValuePairs && structuredData.keyValuePairs.length > 0) {
        prompt += `\n\nKey-Value Pairs:`;
        structuredData.keyValuePairs.forEach((pair: any) => {
          prompt += `\n- ${pair.key}: ${pair.value} (Page ${pair.pageNumber})`;
        });
      }

      if (structuredData.tables && structuredData.tables.length > 0) {
        prompt += `\n\nTables:`;
        structuredData.tables.forEach((table: any, index: number) => {
          prompt += `\n\nTable ${index + 1} (Page ${table.pageNumber}):`;
          table.rows.forEach((row: string[], rowIndex: number) => {
            prompt += `\n${rowIndex === 0 ? 'Headers: ' : 'Row: '}${row.join(' | ')}`;
          });
        });
      }
    }

    prompt += `\n\nQuestion: ${question}

Please provide a clear and concise answer based only on the information in the document. If the answer cannot be found in the document, please say so.`;

    return prompt;
  }
}